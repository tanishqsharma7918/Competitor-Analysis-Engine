(make executable)

4) `main.py` â€” FastAPI app + static UI
```python
from fastapi import FastAPI, BackgroundTasks, Request
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
import uuid, os, json
from research_agent.agent import AgentRunner
import asyncio

app = FastAPI(title="IoMT Competitor Analysis API")

# serve static UI from /static
if not os.path.exists("static"):
    os.makedirs("static")
app.mount("/static", StaticFiles(directory="static"), name="static")

class AnalyzeRequest(BaseModel):
    competitors: list[str]
    max_steps: int = 5

# in-memory runs (simple; for production use a DB)
RUNS = {}

@app.post("/api/analyze")
async def analyze(req: AnalyzeRequest, background_tasks: BackgroundTasks, request: Request):
    # create run id
    run_id = str(uuid.uuid4())
    RUNS[run_id] = {"status": "queued", "logs": [], "result": None}
    # start background processing
    background_tasks.add_task(run_analysis, run_id, req.competitors, req.max_steps)
    return {"run_id": run_id}

@app.get("/api/status/{run_id}")
async def status(run_id: str):
    r = RUNS.get(run_id)
    if not r:
        return JSONResponse(status_code=404, content={"error": "run not found"})
    return r

@app.get("/api/download/{run_id}")
async def download(run_id: str):
    r = RUNS.get(run_id)
    if not r or not r.get("result"):
        return JSONResponse(status_code=404, content={"error": "not available"})
    # build CSV from download_report_csv_rows if present
    rows = r["result"].get("download_report_csv_rows", [])
    import pandas as pd, io
    df = pd.DataFrame(rows)
    csv_bytes = df.to_csv(index=False).encode("utf-8")
    return JSONResponse(content={"csv": csv_bytes.decode("utf-8")})

async def run_analysis(run_id, competitors, max_steps):
    # robust wrapper for AgentRunner
    RUNS[run_id]["status"] = "running"
    try:
        # read secrets from env
        import os
        api_key = os.getenv("OPENAI_API_KEY", "")
        runner = AgentRunner(api_key=api_key)
        # prepare payload
        payload = {"competitors": competitors, "max_steps": max_steps}
        runner.add_message("system", runner.SYSTEM_PROMPT)  # use embedded prompt from agent if present
        runner.add_message("user", json.dumps(payload))
        steps = 0
        while not runner.complete and steps < max_steps:
            steps += 1
            RUNS[run_id]["logs"].append(f"STEP {steps} - starting")
            msg = runner.step()
            RUNS[run_id]["logs"].append(f"STEP {steps} - msg: {str(msg)[:200]}")
            await asyncio.sleep(0.1)
        RUNS[run_id]["result"] = runner.final_result or {}
        RUNS[run_id]["status"] = "complete"
    except Exception as e:
        RUNS[run_id]["status"] = "error"
        RUNS[run_id]["logs"].append(f"ERROR: {str(e)}")
